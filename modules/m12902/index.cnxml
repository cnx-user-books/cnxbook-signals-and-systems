<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:md="http://cnx.rice.edu/mdml">

  <title>Tipos de Bases</title>

  <metadata><md:content-id>undefined</md:content-id><md:title/><md:uuid>ab869486-86fd-47e9-9cbf-85f9af836598</md:uuid>
</metadata>

  <content>
    
    <section id="norm_b">
      <title>Base Normada</title>
      <para id="p1_sec1a">
	
	<definition id="normal_basis">
	<term>Base Normada</term>
	<meaning id="idm1278528">
	    una <link document="m12862" target-id="sec_bas" strength="3">base</link>
		<m:math>
			<m:set>
				<m:ci><m:msub>
						<m:mi>b</m:mi>
						<m:mi>i</m:mi>
					</m:msub></m:ci>
			</m:set>
		</m:math> donde cada
	    <m:math>
			<m:ci><m:msub>
					<m:mi>b</m:mi>
					<m:mi>i</m:mi>
				</m:msub></m:ci>
		</m:math> tiene una norma unitaria

	    <equation id="eq1a">
			<m:math>
				<m:apply>
					<m:forall/>
					<m:bvar>
						<m:ci>i</m:ci>
					</m:bvar>
					<m:condition>
						<m:apply>
							<m:in/>
							<m:ci>i</m:ci>
							<m:integers/>
						</m:apply>
					</m:condition>
					<m:apply>
						<m:eq/>
						<m:apply>
							<m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#norm"/>
							<m:ci><m:msub>
									<m:mi>b</m:mi>
									<m:mi>i</m:mi>
								</m:msub></m:ci>
						</m:apply>
						<m:cn>1</m:cn>
					</m:apply>
				</m:apply>
			</m:math>
		</equation>
	</meaning>
</definition>

	<note type="nota" id="idm7243216"><label>Nota</label>
	  El concepto de bases se aplica a todos los <link document="m12878" strength="3">espacios vectoriales</link>.  El concepto de 	  <term>base normada</term> se aplica solo a <link document="m12877" strength="3">espacios normados</link>.
	</note>

	También usted puede normalizar una base: solo multiplique cada vector de la base por una constante, tal que  
	<m:math>
	  <m:apply>
	    <m:divide/>
	    <m:cn>1</m:cn>
	    <m:apply>
	      <m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#norm"/>
	      <m:ci><m:msub>
		<m:mi>b</m:mi>
		<m:mi>i</m:mi>
	      </m:msub></m:ci>
	    </m:apply>
	  </m:apply>
	</m:math>
      </para>
      
      <example id="eg1a">
	<para id="p1_eg1a">
	  Dada la siguiente base:

	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:set>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>b</m:mi>
		    <m:mn>0</m:mn>
		  </m:msub>
		</m:ci>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>b</m:mi>
		    <m:mn>1</m:mn>
		  </m:msub>
		</m:ci>
	      </m:set>
	      <m:set>
		<m:matrix>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		</m:matrix>
		<m:matrix>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		  <m:matrixrow>
		    <m:cn>-1</m:cn>
		  </m:matrixrow>
		</m:matrix>
	      </m:set>
	    </m:apply>
	  </m:math>

	  Normalizado con la norma
	  <m:math>
	      <m:ci><m:msup>
		<m:mi>ℓ</m:mi>
		<m:mn>2</m:mn>
	      </m:msup></m:ci>
	  </m:math>:
	  
	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:ci type="vector">
		<m:msub>
		  <m:mover accent="true">
		    <m:mi>b</m:mi>
		    <m:mo>~</m:mo>
		  </m:mover>
		  <m:mn>0</m:mn>
		</m:msub>
	      </m:ci>
	       <m:apply>
		<m:times/>
		<m:apply>
		  <m:divide/>
		  <m:cn>1</m:cn>
		  <m:apply>
		    <m:root/>
		    <m:cn>2</m:cn>
		  </m:apply>
		</m:apply>
		<m:matrix>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		</m:matrix>
	      </m:apply>
	    </m:apply>
	  </m:math>
	   
	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:ci type="vector">
		<m:msub>
		  <m:mover accent="true">
		    <m:mi>b</m:mi>
		    <m:mo>~</m:mo>
		  </m:mover>
		  <m:mn>1</m:mn>
		</m:msub>
	      </m:ci>
	      <m:apply>
		<m:times/>
		<m:apply>
		  <m:divide/>
		  <m:cn>1</m:cn>
		  <m:apply>
		    <m:root/>
		    <m:cn>2</m:cn>
		  </m:apply>
		</m:apply>
		<m:matrix>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		  <m:matrixrow>
		    <m:cn>-1</m:cn>
		  </m:matrixrow>
		</m:matrix>
	      </m:apply>
	    </m:apply>
	  </m:math>

	    Normalizado con la norma 
	  <m:math>
	      <m:ci><m:msup>
		<m:mi>ℓ</m:mi>
		<m:mn>1</m:mn>
	      </m:msup></m:ci>
	  </m:math>:
	  
	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:ci type="vector">
		<m:msub>
		  <m:mover accent="true">
		    <m:mi>b</m:mi>
		    <m:mo>~</m:mo>
		  </m:mover>
		  <m:mn>0</m:mn>
		</m:msub>
	      </m:ci>
	       <m:apply>
		<m:times/>
		<m:apply>
		  <m:divide/>
		  <m:cn>1</m:cn>
		  <m:cn>2</m:cn>
		</m:apply>
		<m:matrix>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		</m:matrix>
	      </m:apply>
	    </m:apply>
	  </m:math>
	   
	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:ci type="vector">
		<m:msub>
		  <m:mover accent="true">
		    <m:mi>b</m:mi>
		    <m:mo>~</m:mo>
		  </m:mover>
		  <m:mn>1</m:mn>
		</m:msub>
	      </m:ci>
	      <m:apply>
		<m:times/>
		<m:apply>
		  <m:divide/>
		  <m:cn>1</m:cn>
		  <m:cn>2</m:cn>
		</m:apply>
		<m:matrix>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		  <m:matrixrow>
		    <m:cn>-1</m:cn>
		  </m:matrixrow>
		</m:matrix>
	      </m:apply>
	    </m:apply>
	  </m:math>
	</para>		  
      </example>
    </section>


    <section id="orthog_b">
      <title>Base Ortogonal </title>
      <para id="p1_sec1">
	
	<definition id="orthog_basis">
	  <term>Base Ortogonal </term>
	  <meaning id="idp2187360">
	    una base 
	    <m:math>
	      <m:set>
		<m:ci><m:msub>
		  <m:mi>b</m:mi>
		  <m:mi>i</m:mi>
		</m:msub></m:ci>
	      </m:set>
	    </m:math> en donde los elementos son <term>mutuamente ortogonales </term>

	    <m:math display="block">
	      <m:apply>
		<m:forall/>
		<m:bvar>
		  <m:ci>i</m:ci>
		</m:bvar>
		<m:condition>
		  <m:apply>
		    <m:neq/>
		    <m:ci>i</m:ci>
		    <m:ci>j</m:ci>
		  </m:apply>
		</m:condition>
		<m:apply>
		  <m:eq/>
		  <m:apply>
		    <m:scalarproduct/>
		    <m:ci><m:msub>
		      <m:mi>b</m:mi>
		      <m:mi>i</m:mi>
		    </m:msub></m:ci>
		    <m:ci><m:msub>
		      <m:mi>b</m:mi>
		      <m:mi>j</m:mi>
		    </m:msub></m:ci>
		  </m:apply>
		  <m:cn>0</m:cn>
		</m:apply>
	      </m:apply>
	    </m:math>
	  </meaning>
	</definition>

	<note type="nota" id="idm8200496"><label>Nota</label>
	  El concepto de base ortogonal se aplica solo a los <link document="m12879" target-id="sec2" strength="3">Espacios de Hilbert
	  </link>. 
	</note>
      </para>

      <example id="eg1">
	<para id="p1_eg1">
	  Base canónica para 
	  <m:math>
	    <m:ci><m:msup>
	      <m:mi>ℝ</m:mi>
	      <m:mn>2</m:mn>
	    </m:msup></m:ci>
	  </m:math>, también referida como 
	  <m:math>
	    <m:apply>
	      <m:ci type="fn">
		<m:msup>
		  <m:mi>ℓ</m:mi>
		  <m:mn>2</m:mn>
		</m:msup>
	      </m:ci>
	      <m:interval>
		<m:cn>0</m:cn>
		<m:cn>1</m:cn>
	      </m:interval>
	    </m:apply>
	  </m:math>:

	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:ci type="vector">
		<m:msub>
		  <m:mi>b</m:mi>
		  <m:mn>0</m:mn>
		</m:msub>
	      </m:ci>
	      <m:matrix>
		<m:matrixrow>
		  <m:cn>1</m:cn>
		</m:matrixrow>
		<m:matrixrow>
		  <m:cn>0</m:cn>
		</m:matrixrow>
	      </m:matrix>
	    </m:apply>
	  </m:math>
	      
	   <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:ci type="vector">
		<m:msub>
		  <m:mi>b</m:mi>
		  <m:mn>1</m:mn>
		</m:msub>
	      </m:ci>
	      <m:matrix>
		<m:matrixrow>
		  <m:cn>0</m:cn>
		</m:matrixrow>
		<m:matrixrow>
		  <m:cn>1</m:cn>
		</m:matrixrow>
	      </m:matrix>
	    </m:apply>
	  </m:math>

	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:apply>
		<m:scalarproduct/>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>b</m:mi>
		    <m:mn>0</m:mn>
		  </m:msub>
		</m:ci>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>b</m:mi>
		    <m:mn>1</m:mn>
		  </m:msub>
		</m:ci>
	      </m:apply>
	      <m:apply>
		<m:sum/>
		<m:bvar>
		  <m:ci>i</m:ci>
		</m:bvar>
		<m:uplimit>
		  <m:cn>1</m:cn>
		</m:uplimit>
		<m:lowlimit>
		  <m:cn>0</m:cn>
		</m:lowlimit>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:ci type="fn" class="discrete">
		      <m:msub>
			<m:mi>b</m:mi>
			<m:mn>0</m:mn>
		      </m:msub>
		    </m:ci>
		    <m:ci>i</m:ci>
		  </m:apply>
		  <m:apply>
		    <m:ci type="fn" class="discrete">
		      <m:msub>
			<m:mi>b</m:mi>
			<m:mn>1</m:mn>
		      </m:msub>
		    </m:ci>
		    <m:ci>i</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:plus/>
		<m:apply>
		  <m:times/>
		  <m:cn>1</m:cn>
		  <m:cn>0</m:cn>
		</m:apply>
		<m:apply>
		  <m:times/>
		  <m:cn>0</m:cn>
		  <m:cn>1</m:cn>
		</m:apply>
	      </m:apply>
	      <m:cn>0</m:cn>
	    </m:apply>
	  </m:math>
		  
	</para>
      </example>

      <example id="eg2">
	<para id="p1_eg2">
	  
	  Ahora tenemos la siguiente base y relación:
	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:set>
		<m:matrix>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		</m:matrix>
		<m:matrix>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		  <m:matrixrow>
		    <m:cn>-1</m:cn>
		  </m:matrixrow>
		</m:matrix>
	      </m:set>
	      <m:set>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>h</m:mi>
		    <m:mn>0</m:mn>
		  </m:msub>
		</m:ci>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>h</m:mi>
		    <m:mn>1</m:mn>
		  </m:msub>
		</m:ci>
	      </m:set>
	    </m:apply>
	  </m:math>

	  
	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:apply>
		<m:scalarproduct/>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>h</m:mi>
		    <m:mn>0</m:mn>
		  </m:msub>
		</m:ci>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>h</m:mi>
		    <m:mn>1</m:mn>
		  </m:msub>
		</m:ci>
	      </m:apply>
	      <m:apply>
		<m:plus/>
		<m:apply>
		  <m:times/>
		  <m:cn>1</m:cn>
		  <m:cn>1</m:cn>
		</m:apply>
		<m:apply>
		  <m:times/>
		  <m:cn>1</m:cn>
		  <m:cn>-1</m:cn>
		</m:apply>
	      </m:apply>
	      <m:cn>0</m:cn>
	    </m:apply>
	  </m:math>	      

	</para>
      </example>
    </section>


    <section id="orthon_b">
      <title>Base Ortonormal </title>
      <para id="p1_sec2">
	Colocando las dos secciones (definiciones) anteriores juntas, llegamos al tipo de base más importante y útil:
	
	<definition id="orthon_basis">
		<term>Base Ortonormal</term>
		<meaning id="idm1293904">
	    Una base que es <term>normalizada</term> y	    <term>ortogonal</term>
			<m:math display="block">
				<m:apply>
					<m:forall/>
					<m:bvar>
						<m:ci>i</m:ci>
					</m:bvar>
					<m:condition>
						<m:apply>
							<m:in/>
							<m:ci>i</m:ci>
							<m:integers/>
						</m:apply>
					</m:condition>
					<m:apply>
						<m:eq/>
						<m:apply>
							<m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#norm"/>
							<m:ci><m:msub>
									<m:mi>b</m:mi>
									<m:mi>i</m:mi>
								</m:msub></m:ci>
						</m:apply>
						<m:cn>1</m:cn>
					</m:apply>
				</m:apply>
			</m:math>
			<m:math display="block">
				<m:apply>
					<m:forall/>
					<m:bvar>
						<m:ci>i</m:ci>
					</m:bvar>
					<m:condition>
						<m:apply>
							<m:neq/>
							<m:ci>i</m:ci>
							<m:ci>j</m:ci>
						</m:apply>
					</m:condition>
					<m:apply>
						<m:scalarproduct/>
						<m:ci><m:msub>
								<m:mi>b</m:mi>
								<m:mi>i</m:mi>
							</m:msub></m:ci>
						<m:ci><m:msub>
								<m:mi>b</m:mi>
								<m:mi>j</m:mi>
							</m:msub></m:ci>
					</m:apply>
				</m:apply>
			</m:math>
		</meaning>
	</definition>
	<note type="notación" id="idm109872"><label>Notación</label>
	  podemos acortar los dos argumentos en uno solo:

	  <m:math display="block">
		<m:apply>
			<m:eq/>
			<m:apply>
				<m:scalarproduct/>
				<m:ci><m:msub>
						<m:mi>b</m:mi>
						<m:mi>i</m:mi>
					</m:msub></m:ci>
				<m:ci><m:msub>
						<m:mi>b</m:mi>
						<m:mi>j</m:mi>
					</m:msub></m:ci>
			</m:apply>
			<m:ci><m:msub>
					<m:mi>δ</m:mi>
					<m:mrow>
						<m:mi>i</m:mi>
						<m:mi>j</m:mi>
					</m:mrow>
				</m:msub></m:ci>
		</m:apply>
	</m:math>

	  donde 

	  <m:math display="block">
		<m:apply>
			<m:eq/>
			<m:ci><m:msub>
					<m:mi>δ</m:mi>
					<m:mrow>
						<m:mi>i</m:mi>
						<m:mi>j</m:mi>
					</m:mrow>
				</m:msub></m:ci>
			<m:piecewise>
				<m:piece>
					<m:cn>1</m:cn>
					<m:apply>
						<m:eq/>
						<m:ci>i</m:ci>
						<m:ci>j</m:ci>
					</m:apply>
				</m:piece>
				<m:piece>
					<m:cn>0</m:cn>
					<m:apply>
						<m:neq/>
						<m:ci>i</m:ci>
						<m:ci>j</m:ci>
					</m:apply>
				</m:piece>
			</m:piecewise>
		</m:apply>
	</m:math>

	  Donde 
	  <m:math>
		<m:ci><m:msub>
				<m:mi>δ</m:mi>
				<m:mrow>
					<m:mi>i</m:mi>
					<m:mi>j</m:mi>
				</m:mrow>
			</m:msub></m:ci>
	</m:math>
	  re refiere a la <link document="m18124" strength="3">función delta </link> Kronecker que también es escrita como 
	 	  <m:math>
		<m:apply>
			<m:ci type="fn" class="discrete">δ</m:ci>
			<m:apply>
				<m:minus/>
				<m:ci>i</m:ci>
				<m:ci>j</m:ci>
			</m:apply>
		</m:apply>
	</m:math>.
	</note>
</para>

      <example id="eg1_orthon">
	<title>Ejemplo de Base Ortonormal  #1</title>
	<para id="p1_eg1or">
	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:set>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>b</m:mi>
		    <m:mn>0</m:mn>
		  </m:msub>
		</m:ci>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>b</m:mi>
		    <m:mn>2</m:mn>
		  </m:msub>
		</m:ci>
	      </m:set>
	      <m:set>
		<m:matrix>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		  <m:matrixrow>
		    <m:cn>0</m:cn>
		  </m:matrixrow>
		</m:matrix>
		<m:matrix>
		  <m:matrixrow>
		    <m:cn>0</m:cn>
		  </m:matrixrow>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		</m:matrix>
	      </m:set>
	    </m:apply>
	  </m:math>
	</para>
      </example>

       <example id="eg2_orthon">
	<title>Ejemplo de Base Ortonormal  #2</title>
	<para id="p1_eg2or">
	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:set>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>b</m:mi>
		    <m:mn>0</m:mn>
		  </m:msub>
		</m:ci>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>b</m:mi>
		    <m:mn>2</m:mn>
		  </m:msub>
		</m:ci>
	      </m:set>
	      <m:set>
		<m:matrix>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		</m:matrix>
		<m:matrix>
		  <m:matrixrow>
		    <m:cn>1</m:cn>
		  </m:matrixrow>
		  <m:matrixrow>
		    <m:cn>-1</m:cn>
		  </m:matrixrow>
		</m:matrix>
	      </m:set>
	    </m:apply>
	  </m:math>
	</para>
      </example>

      <example id="eg3_orthon">
	<title>Ejemplo de Base Ortonormal  #3</title>
	<para id="p1_eg3or">
	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:set>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>b</m:mi>
		    <m:mn>0</m:mn>
		  </m:msub>
		</m:ci>
		<m:ci type="vector">
		  <m:msub>
		    <m:mi>b</m:mi>
		    <m:mn>2</m:mn>
		  </m:msub>
		</m:ci>
	      </m:set>
	      <m:set>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:divide/>
		    <m:cn>1</m:cn>
		    <m:apply>
		      <m:root/>
		      <m:cn>2</m:cn>
		    </m:apply>
		  </m:apply>
		  <m:matrix>
		    <m:matrixrow>
		      <m:cn>1</m:cn>
		    </m:matrixrow>
		    <m:matrixrow>
		      <m:cn>1</m:cn>
		    </m:matrixrow>
		  </m:matrix>
		</m:apply>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:divide/>
		    <m:cn>1</m:cn>
		    <m:apply>
		      <m:root/>
		      <m:cn>2</m:cn>
		    </m:apply>
		  </m:apply>
		  <m:matrix>
		    <m:matrixrow>
		      <m:cn>1</m:cn>
		    </m:matrixrow>
		    <m:matrixrow>
		      <m:cn>-1</m:cn>
		    </m:matrixrow>
		  </m:matrix>
		</m:apply>
	      </m:set>
	    </m:apply>
	  </m:math>
	</para>
      </example>

      <section id="sub1">
	<title>La belleza de las Bases Ortonormales</title>
	<para id="p1_sub1">
	  Trabajar con las bases Ortonormales es sencillo.Si	  <m:math>
	    <m:set>
	      <m:ci><m:msub>
		<m:mi>b</m:mi>
		<m:mi>i</m:mi>
	      </m:msub></m:ci>
	    </m:set>
	  </m:math> es una base ortonormal, podemos escribir para cualquier
	  <m:math><m:ci>x</m:ci></m:math>

	  <equation id="eq1">
	    <m:math>
	      <m:apply>
		<m:eq/>
		<m:ci>x</m:ci>
		<m:apply>
		  <m:sum/>
		  <m:domainofapplication>
		    <m:ci>i</m:ci>
		  </m:domainofapplication>
		  <m:apply>
		    <m:times/>
		    <m:ci><m:msub>
		      <m:mi>α</m:mi>
		      <m:mi>i</m:mi>
		    </m:msub></m:ci>
		    <m:ci><m:msub>
		      <m:mi>b</m:mi>
		      <m:mi>i</m:mi>
		    </m:msub></m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:math>
	  </equation>

	  Es fácil encontrar los 
	  <m:math>
	    <m:ci><m:msub>
	      <m:mi>α</m:mi>
	      <m:mi>i</m:mi>
	    </m:msub></m:ci>
	  </m:math>:

	  <equation id="eq2">
	    <m:math>
	      <m:apply>
		<m:eq/>
		<m:apply>
		  <m:scalarproduct/>
		  <m:ci>x</m:ci>
		  <m:ci><m:msub>
		    <m:mi>b</m:mi>
		    <m:mi>i</m:mi>
		  </m:msub></m:ci>
		</m:apply>
		<m:apply>
		  <m:scalarproduct/>
		  <m:apply>
		    <m:sum/>
		    <m:domainofapplication>
		      <m:ci>k</m:ci>
		    </m:domainofapplication>
		    <m:apply>
		      <m:times/>
		      <m:ci><m:msub>
			<m:mi>α</m:mi>
			<m:mi>k</m:mi>
		      </m:msub></m:ci>
		      <m:ci><m:msub>
			<m:mi>b</m:mi>
			<m:mi>k</m:mi>
		      </m:msub></m:ci>
		    </m:apply>
		  </m:apply>
		  <m:ci><m:msub>
		    <m:mi>b</m:mi>
		    <m:mi>i</m:mi>
		  </m:msub></m:ci>
		</m:apply>
		<m:apply>
		  <m:sum/>
		  <m:domainofapplication>
		    <m:ci>k</m:ci>
		  </m:domainofapplication>
		  <m:apply>
		    <m:times/>
		    <m:ci><m:msub>
		      <m:mi>α</m:mi>
		      <m:mi>k</m:mi>
		    </m:msub></m:ci>
		    <m:apply>
		      <m:scalarproduct/>
		      <m:ci><m:msub>
			<m:mi>b</m:mi>
			<m:mi>k</m:mi>
		      </m:msub></m:ci>
		      <m:ci><m:msub>
			<m:mi>b</m:mi>
			<m:mi>i</m:mi>
		      </m:msub></m:ci>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:math>
	  </equation>
	  
	  En donde en la ecuación anterior podemos usar el conocimiento de la función delta para reducir la ecuación:

	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:apply>
		<m:scalarproduct/>
		<m:ci><m:msub>
		  <m:mi>b</m:mi>
		  <m:mi>k</m:mi>
		</m:msub></m:ci>
		<m:ci><m:msub>
		  <m:mi>b</m:mi>
		  <m:mi>i</m:mi>
		</m:msub></m:ci>
	      </m:apply>
	      <m:ci><m:msub>
		<m:mi>δ</m:mi>
		  <m:mrow>
		    <m:mi>i</m:mi>
		    <m:mi>k</m:mi>
		  </m:mrow>
		</m:msub></m:ci>
	      <m:piecewise>
		<m:piece>
		  <m:cn>1</m:cn>
		  <m:apply>
		    <m:eq/>
		    <m:ci>i</m:ci>
		    <m:ci>k</m:ci>
		  </m:apply>
		</m:piece>
		<m:piece>
		  <m:cn>0</m:cn>
		  <m:apply>
		    <m:neq/>
		    <m:ci>i</m:ci>
		    <m:ci>k</m:ci>
		  </m:apply>
		</m:piece>
	      </m:piecewise>
	    </m:apply>
	  </m:math>

	  <equation id="eq3">
	    <m:math>
	      <m:apply>
		<m:eq/>
		<m:apply>
		  <m:scalarproduct/>
		  <m:ci>x</m:ci>
		  <m:ci><m:msub>
		    <m:mi>b</m:mi>
		    <m:mi>i</m:mi>
		  </m:msub></m:ci>
		</m:apply>
		<m:ci><m:msub>
		  <m:mi>α</m:mi>
		  <m:mi>i</m:mi>
		</m:msub></m:ci>
	      </m:apply>
	    </m:math>
	  </equation>

	  Por lo tanto podemos concluir con la siguiente ecuación importante para <m:math><m:ci>x</m:ci></m:math>:

	  <equation id="eq4">
	    <m:math>
	      <m:apply>
		<m:eq/>
		<m:ci>x</m:ci>
		<m:apply>
		  <m:sum/>
		  <m:domainofapplication>
		    <m:ci>i</m:ci>
		  </m:domainofapplication>
		  <m:apply>
		    <m:times/>
		    <m:apply>
		      <m:scalarproduct/>
		      <m:ci>x</m:ci>
		      <m:ci><m:msub>
			<m:mi>b</m:mi>
			<m:mi>i</m:mi>
		      </m:msub></m:ci>
		    </m:apply>
		    <m:ci><m:msub>
		      <m:mi>b</m:mi>
		      <m:mi>i</m:mi>
		    </m:msub></m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:math>
	  </equation>

	  Los
	  <m:math>
	    <m:ci><m:msub>
	      <m:mi>α</m:mi>
	      <m:mi>i</m:mi>
	    </m:msub></m:ci>
	  </m:math>'s son fáciles de calcular (sin interacción entres los 
	  <m:math>
	    <m:ci><m:msub>
	      <m:mi>b</m:mi>
	      <m:mi>i</m:mi>
	    </m:msub></m:ci>
	  </m:math>'s)
	</para>

	<example id="eg_orthon">
	  <para id="p1_egorthon">
	    Dada la siguiente base:
	    
	    <m:math display="block">
	      <m:apply>
		<m:eq/>
		<m:set>
		  <m:ci type="vector">
		    <m:msub>
		      <m:mi>b</m:mi>
		      <m:mn>0</m:mn>
		    </m:msub>
		  </m:ci>
		  <m:ci type="vector">
		    <m:msub>
		      <m:mi>b</m:mi>
		      <m:mn>1</m:mn>
		    </m:msub>
		  </m:ci>
		</m:set>
		<m:set>
		  <m:apply>
		    <m:times/>
		    <m:apply>
		      <m:divide/>
		      <m:cn>1</m:cn>
		      <m:apply>
			<m:root/>
			<m:cn>2</m:cn>
		      </m:apply>
		    </m:apply>
		    <m:matrix>
		      <m:matrixrow>
			<m:cn>1</m:cn>
		      </m:matrixrow>
		      <m:matrixrow>
			<m:cn>1</m:cn>
		      </m:matrixrow>
		    </m:matrix>
		  </m:apply>
		  <m:apply>
		    <m:times/>
		    <m:apply>
		      <m:divide/>
		      <m:cn>1</m:cn>
		      <m:apply>
			<m:root/>
			<m:cn>2</m:cn>
		      </m:apply>
		    </m:apply>
		    <m:matrix>
		      <m:matrixrow>
			<m:cn>1</m:cn>
		      </m:matrixrow>
		      <m:matrixrow>
			<m:cn>-1</m:cn>
		      </m:matrixrow>
		    </m:matrix>
		  </m:apply>
		</m:set>
	      </m:apply>
	    </m:math>

	    representa

	    <m:math>
	      <m:apply>
		<m:eq/>
		<m:ci>x</m:ci>
		<m:matrix>
		  <m:matrixrow>
		    <m:cn>3</m:cn>
		  </m:matrixrow>
		  <m:matrixrow>
		    <m:cn>2</m:cn>
		  </m:matrixrow>
		</m:matrix>
	      </m:apply>
	    </m:math>
	  </para>
	</example>


	<example id="eg2a_orthon">
	  <title>Serie de Fourier Levemente Modificada</title>
	  <para id="p1_eg2aorthon">
	    Dada la base
	    
	    <m:math display="block">
	      <m:apply>
		<m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#evaluateat"/>
		<m:bvar>
		  <m:ci>n</m:ci>
		</m:bvar>
		<m:uplimit>
		  <m:infinity/>
		</m:uplimit>
		<m:lowlimit>
		  <m:apply>
		    <m:minus/>
		    <m:infinity/>
		  </m:apply>
		</m:lowlimit>
		<m:apply>
		  <m:set>
		    <m:apply>
		      <m:times/>
		      <m:apply>
			<m:divide/>
			<m:cn>1</m:cn>
			<m:apply>
			  <m:root/>
			  <m:ci>T</m:ci>
			</m:apply>
		      </m:apply>
		      <m:apply>
			<m:exp/>
			<m:apply>
			  <m:times/>
			  <m:imaginaryi/>
			  <m:ci><m:msub>
			    <m:mi>ω</m:mi>
			    <m:mn>0</m:mn>
			  </m:msub></m:ci>
			  <m:ci>n</m:ci>
			  <m:ci>t</m:ci>
			</m:apply>
		      </m:apply>
		    </m:apply>
		  </m:set>
		</m:apply>
	      </m:apply>
	    </m:math>
	    
	    en 
	    <m:math display="inline">
	      <m:apply>
		<m:ci type="fn">
		  <m:msup>
		    <m:mi>L</m:mi>
		    <m:mn>2</m:mn>
		  </m:msup>
		</m:ci>
		<m:apply>
		  <m:interval>
		    <m:cn>0</m:cn>
		    <m:ci>T</m:ci>
		  </m:interval>
		</m:apply>
	      </m:apply>
	    </m:math> 
	    donde
	    <m:math display="inline">
	      <m:apply>
		<m:eq/>
		<m:ci>T</m:ci>
		<m:apply>
		  <m:divide/>
		  <m:apply>
		    <m:times/>
		    <m:cn>2</m:cn>
		    <m:pi/>
		  </m:apply>
		  <m:ci><m:msub>
		    <m:mi>ω</m:mi>
		    <m:mn>0</m:mn>
		  </m:msub></m:ci>
		</m:apply>
	      </m:apply>
	    </m:math>.  

	    <m:math display="block">
	      <m:apply>
		<m:eq/>
		<m:apply>
		  <m:ci type="fn">f</m:ci>
		  <m:ci>t</m:ci>
		</m:apply>
		<m:apply>
		  <m:sum/>
		  <m:bvar>
		    <m:ci>n</m:ci>
		  </m:bvar>
		  <m:uplimit>
		    <m:infinity/>
		  </m:uplimit>
		  <m:lowlimit>
		    <m:apply>
		      <m:minus/>
		      <m:infinity/>
		    </m:apply>
		  </m:lowlimit>
		  <m:apply>
		    <m:times/>
		    <m:apply>
		      <m:scalarproduct/>
		      <m:ci>f</m:ci>
		      <m:apply>
			<m:exp/>
			<m:apply>
			  <m:times/>
			  <m:imaginaryi/>
			  <m:ci><m:msub>
			    <m:mi>ω</m:mi>
			    <m:mn>0</m:mn>
			  </m:msub></m:ci>
			  <m:ci>n</m:ci>
			  <m:ci>t</m:ci>
			</m:apply>
		      </m:apply>
		    </m:apply>
		    <m:apply>
		      <m:exp/>
		      <m:apply>
			<m:times/>
			<m:imaginaryi/>
			<m:ci><m:msub>
			  <m:mi>ω</m:mi>
			  <m:mn>0</m:mn>
			</m:msub></m:ci>
			<m:ci>n</m:ci>
			<m:ci>t</m:ci>
		      </m:apply>
		    </m:apply>
		    <m:apply>
		      <m:divide/>
		      <m:cn>1</m:cn>
		      <m:apply>
			<m:root/>
			<m:ci>T</m:ci>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:math>

	    Donde podemos calcular el producto interior de arriba en
	    <m:math>
	      <m:ci><m:msup>
		<m:mi>L</m:mi>
		<m:mn>2</m:mn>
	      </m:msup></m:ci>
	    </m:math> como 

	    <m:math display="block">
	      <m:apply>
		<m:eq/>
		<m:apply>
		  <m:scalarproduct/>
		  <m:ci>f</m:ci>
		  <m:apply>
		    <m:exp/>
		    <m:apply>
		      <m:times/>
		      <m:imaginaryi/>
		      <m:ci><m:msub>
			<m:mi>ω</m:mi>
			<m:mn>0</m:mn>
		      </m:msub></m:ci>
		      <m:ci>n</m:ci>
		      <m:ci>t</m:ci>
		    </m:apply>
		  </m:apply>
		</m:apply>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:divide/>
		    <m:cn>1</m:cn>
		    <m:apply>
		      <m:root/>
		      <m:ci>T</m:ci>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:int/>
		    <m:bvar>
		      <m:ci>t</m:ci>
		    </m:bvar>
		    <m:uplimit>
		      <m:ci>T</m:ci>
		    </m:uplimit>
		    <m:lowlimit>
		      <m:cn>0</m:cn>
		    </m:lowlimit>
		    <m:apply>
		      <m:times/>
		      <m:apply>
			<m:ci type="fn">f</m:ci>
			<m:ci>t</m:ci>
		      </m:apply>
		      <m:apply>
			<m:conjugate/>
			<m:apply>
			  <m:exp/>
			  <m:apply>
			    <m:times/>
			    <m:imaginaryi/>
			    <m:ci><m:msub>
			      <m:mi>ω</m:mi>
			      <m:mn>0</m:mn>
			    </m:msub></m:ci>
			    <m:ci>n</m:ci>
			    <m:ci>t</m:ci>
			  </m:apply>
			</m:apply>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:apply>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:divide/>
		    <m:cn>1</m:cn>
		    <m:apply>
		      <m:root/>
		      <m:ci>T</m:ci>
		    </m:apply>
		  </m:apply>
		  <m:apply>
		    <m:int/>
		    <m:bvar>
		      <m:ci>t</m:ci>
		    </m:bvar>
		    <m:uplimit>
		      <m:ci>T</m:ci>
		    </m:uplimit>
		    <m:lowlimit>
		      <m:cn>0</m:cn>
		    </m:lowlimit>
		    <m:apply>
		      <m:times/>
		      <m:apply>
			<m:ci type="fn">f</m:ci>
			<m:ci>t</m:ci>
		      </m:apply>
		      <m:apply>
			<m:exp/>
			<m:apply>
			  <m:minus/>
			  <m:apply>
			    <m:times/>
			    <m:imaginaryi/>
			    <m:ci><m:msub>
			      <m:mi>ω</m:mi>
			      <m:mn>0</m:mn>
			    </m:msub></m:ci>
			    <m:ci>n</m:ci>
			    <m:ci>t</m:ci>
			  </m:apply>
			</m:apply>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:math>
	    
	  </para>
	</example>
      </section>


      <section id="sub2">
	<title>7.7.3.2	Expansión de una Base Ortonormal en un Espacio Hilbert</title>
	<para id="p1_sub2">
	  Sea
	  <m:math>
	    <m:set>
	      <m:ci><m:msub>
		<m:mi>b</m:mi>
		<m:mi>i</m:mi>
	      </m:msub></m:ci>
	    </m:set>
	  </m:math>
	  una base ortonormal para un espacio de Hilbert	  <m:math><m:ci>H</m:ci></m:math>.  Entonces, para cualquier 
	  
	  <m:math>
	    <m:apply>
	      <m:in/>
	      <m:ci>x</m:ci>
	      <m:ci>H</m:ci>
	    </m:apply>
	  </m:math>

	podemos escribir

	  <equation id="eq6">
	    <m:math>
	      <m:apply>
		<m:eq/>
		<m:ci>x</m:ci>
		<m:apply>
		  <m:sum/>
		  <m:domainofapplication>
		    <m:ci>i</m:ci>
		  </m:domainofapplication>
		  <m:apply>
		    <m:times/>
		    <m:ci><m:msub>
		      <m:mi>α</m:mi>
		      <m:mi>i</m:mi>
		    </m:msub></m:ci>
		    <m:ci><m:msub>
		      <m:mi>b</m:mi>
		      <m:mi>i</m:mi>
		    </m:msub></m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:math>
	  </equation>

	  donde 
	  <m:math display="inline">
	    <m:apply>
	      <m:eq/>
	      <m:ci><m:msub>
		<m:mi>α</m:mi>
		<m:mi>i</m:mi>
	      </m:msub></m:ci>
	      <m:apply>
		<m:scalarproduct/>
		<m:ci>x</m:ci>
		<m:ci><m:msub>
		  <m:mi>b</m:mi>
		  <m:mi>i</m:mi>
		</m:msub></m:ci>
	      </m:apply>
	    </m:apply>
	  </m:math>.

	  <list id="list1">
	    <item>
	      “Análisis”: descomponer <m:math><m:ci>x</m:ci>
	      </m:math> en términos de 	      <m:math>
		<m:ci><m:msub>
		  <m:mi>b</m:mi>
		  <m:mi>i</m:mi>
		</m:msub></m:ci>
	      </m:math>
	      
	      <equation id="eq7">
		<m:math>
		  <m:apply>
		    <m:eq/>
		    <m:ci><m:msub>
		      <m:mi>α</m:mi>
		      <m:mi>i</m:mi>
		    </m:msub></m:ci>
		    <m:apply>
		      <m:scalarproduct/>
		      <m:ci>x</m:ci>
		      <m:ci><m:msub>
			<m:mi>b</m:mi>
			<m:mi>i</m:mi>
		      </m:msub></m:ci>
		    </m:apply>
		  </m:apply>
		</m:math>
	      </equation>
	    </item>

	    <item>
	      "Síntesis": construir <m:math><m:ci>x</m:ci>
	      </m:math> de una combinación de las 
	      <m:math>
		<m:ci><m:msub>
		  <m:mi>b</m:mi>
		  <m:mi>i</m:mi>
		</m:msub></m:ci>
	      </m:math>
		
	       <equation id="eq8">
		<m:math>
		  <m:apply>
		    <m:eq/>
		    <m:ci>x</m:ci>
		    <m:apply>
		      <m:sum/>
		      <m:domainofapplication>
			<m:ci>i</m:ci>
		      </m:domainofapplication>
		      <m:apply>
			<m:times/>
			<m:ci><m:msub>
			  <m:mi>α</m:mi>
			  <m:mi>i</m:mi>
			</m:msub></m:ci>
			<m:ci><m:msub>
			  <m:mi>b</m:mi>
			  <m:mi>i</m:mi>
			</m:msub></m:ci>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:math>
	      </equation>
	    </item>
	  </list>

	</para>
      </section>


    </section>
  </content>
</document>