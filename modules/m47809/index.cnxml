<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML">
  
  <title>Discrete-Time Signal Operations</title>

  <metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m47809</md:content-id>
  <md:title>Discrete-Time Signal Operations</md:title>
  <md:abstract>This module will look at two signal operations affecting the time parameter of the signal, time shifting and time scaling.  These operations are very common  components to real-world systems and, as such, should be understood thoroughly when learning about signals and systems.</md:abstract>
  <md:uuid>7baf8108-7e54-4bb1-bb21-408a4ba4548d</md:uuid>
</metadata>

<content>
    <section id="eip-184" class="in"><title>Introduction</title><para id="eip-487">This module will look at two signal operations affecting the time parameter of the signal, time shifting and time scaling. While they appear at first to be straightforward extensions of the continuous-time signal operations, there are some intricacies that are particular to discrete-time signals.</para></section>
    
    <section id="eip-987" class="th"><title>Manipulating the Time Parameter</title><section id="eip-427"><title>Time Shifting</title><para id="p2">Time shifting is, as the name suggests, the shifting of a
	signal in time.  This is done by adding or subtracting an integer
	quantity of the shift to the time variable in the function.
	Subtracting a fixed positive quantity from the time variable will shift
	the signal to the right (delay) by the subtracted quantity, while adding a fixed positive amount to
	the time variable will shift the signal to the left (advance) by the added quantity.
      </para><figure id="fig1" orient="vertical"><media id="id1164265888264" alt=""><image src="../../media/timeshift.png" mime-type="image/png"/></media>
	
      <caption><m:math display="inline">
	    <m:apply>
	      <m:ci type="fn" class="discrete">f</m:ci>
	      <m:apply>
		<m:minus/>
		<m:ci>n</m:ci>
		<m:cn>3</m:cn>
	      </m:apply>
	    </m:apply>
	  </m:math>
	  moves (delays) 
	  <m:math display="inline">
	    <m:ci>f</m:ci>
	  </m:math> 
	  to the right by 
	  <m:math display="inline">
	    <m:cn>3</m:cn>
	  </m:math>.
	</caption></figure></section><section id="eip-787"><title>Time Scaling</title><para id="eip-621">Time scaling compresses or dilates a signal by multiplying
	the time variable by some quantity.  If that quantity is greater
	than one, the signal becomes narrower and the operation is
	called decimation. In contrast, if the quantity is less than one, the
	signal becomes wider and the operation is called expansion or interpolation, depending on how the gaps between values are filled.
      </para><section id="eip-652"><title>Decimation</title><para id="eip-928">In decimation, the input of the signal is changed to be  
<m:math display="inline">
	    <m:apply>
	      <m:ci type="fn" class="discrete">f</m:ci>
	      <m:apply>
		<m:times/>
		<m:ci>c</m:ci>
		<m:ci>n</m:ci>
	      </m:apply>
	    </m:apply>
	  </m:math>
. The quantity used for decimation <m:math><m:ci>c</m:ci></m:math> must be an integer so that the input takes values for which a discrete function is properly defined. The decimated signal <m:math display="inline">
	    <m:apply>
	      <m:ci type="fn" class="discrete">f</m:ci>
	      <m:apply>
		<m:times/>
		<m:ci>c</m:ci>
		<m:ci>n</m:ci>
	      </m:apply>
	    </m:apply>
	  </m:math> corresponds to the original signal <m:math display="inline">
	    <m:apply>
	      <m:ci type="fn" class="discrete">f</m:ci>
		<m:ci>n</m:ci>
	    </m:apply>
	  </m:math> where only each <m:math><m:cn>n</m:cn></m:math> sample is preserved (including <m:math><m:apply>
	      <m:ci type="fn" class="discrete">f</m:ci>
		<m:cn>0</m:cn>
	    </m:apply>
	  </m:math>), and so we are throwing away samples of the signal (or decimating it). </para><figure id="fig2" orient="vertical"><media id="id1164240285802" alt=""><image src="../../media/decimation.png" mime-type="image/png"/></media>
	
      <caption><m:math display="inline">
	    <m:apply>
	      <m:ci type="fn" class="discrete">f</m:ci>
	      <m:apply>
		<m:times/>
		<m:cn>2</m:cn>
		<m:ci>n</m:ci>
	      </m:apply>
	    </m:apply>
	  </m:math>
	  decimates 
	  <m:math display="inline"> 
	    <m:ci>f</m:ci> 
	  </m:math> by 
	  <m:math display="inline"> 
	    <m:cn>2</m:cn> 
	  </m:math>.
	</caption></figure></section>

<section id="eip-719"><title>Expansion</title><para id="eip-945">In expansion, the input of the signal is changed to be <m:math display="inline">
	    <m:apply>
	      <m:ci type="fn" class="discrete">f</m:ci>
	      <m:apply>
		<m:divide/>
		<m:ci>n</m:ci>
		<m:ci>c</m:ci>
	      </m:apply>
	    </m:apply>
	  </m:math>
. We know that the signal  <m:math display="inline">
	    <m:apply>
	      <m:ci type="fn" class="discrete">f</m:ci>
		<m:ci>n</m:ci>
	    </m:apply>
	  </m:math>
 is defined only for integer values of the input <m:math><m:ci>n</m:ci></m:math>. Thus, in the expanded signal we can only place the entries of the original signal <m:math><m:ci>f</m:ci></m:math> at values of <m:math><m:ci>n</m:ci></m:math> that are multiples of <m:math><m:ci>c</m:ci></m:math>. In other words, we are spacing the values of the discrete-time signal <m:math><m:apply><m:minus/><m:ci>c</m:ci><m:cn>1</m:cn></m:apply></m:math> entries away from each other. Since the signal is undefined elsewhere, the standard convention in expansion is to fill in the undetermined values with zeros.
</para><figure id="fig21" orient="vertical"><media id="id11642402858021" alt=""><image src="../../media/expansion.png" mime-type="image/png"/></media>
	
      <caption><m:math display="inline">
	    <m:apply>
	      <m:ci type="fn" class="discrete">f</m:ci>
	      <m:apply>
		<m:divide/>
		<m:ci>n</m:ci>
		<m:cn>2</m:cn>
	      </m:apply>
	    </m:apply>
	  </m:math>
	  expands 
	  <m:math display="inline"> 
	    <m:ci>f</m:ci> 
	  </m:math> by 
	  <m:math display="inline"> 
	    <m:cn>2</m:cn> 
	  </m:math>.
	</caption></figure></section><section id="eip-142"><title>Interpolation</title><para id="eip-407">In practice, we may know specific information about the signal of interest that allows us to provide good estimates of the entries of 
<m:math display="inline">
    <m:apply>
	<m:ci type="fn" class="discrete">f</m:ci>
	<m:apply>
	    <m:divide/>
	    <m:ci>n</m:ci>
	    <m:ci>c</m:ci>
	</m:apply>
    </m:apply>
</m:math>
 that are missing after expansion. For example, we may know that the signal is supposed to be piecewise linear, and so knowing the values of 
<m:math display="inline">
    <m:apply>
	<m:ci type="fn" class="discrete">f</m:ci>
	<m:apply>
	    <m:divide/>
	    <m:ci>n</m:ci>
	    <m:ci>c</m:ci>
	</m:apply>
    </m:apply>
</m:math>
 at 
<m:math display="inline">
    <m:apply>
	<m:eq/>
	<m:ci>n</m:ci>
	<m:apply>
	    <m:divide/>
	    <m:ci>m</m:ci>
	    <m:ci>c</m:ci>
	</m:apply>
    </m:apply>
</m:math>
 and  at 
<m:math display="inline">
    <m:apply>
	<m:eq/>
	<m:ci>n</m:ci>
	<m:apply>
	    <m:divide/>
	    <m:apply>
		<m:sum/>
		<m:ci>m</m:ci>
		<m:cn>1</m:cn>
	    </m:apply>
	    <m:ci>c</m:ci>
	</m:apply>
    </m:apply>
</m:math>
 allows us to infer the values for <m:math><m:ci>n</m:ci></m:math> between 
<m:math display="inline">
    <m:apply>
	<m:sum/>
	<m:apply>
	    <m:divide/>
	    <m:ci>m</m:ci>
	    <m:ci>c</m:ci>
	</m:apply>
	<m:cn>1</m:cn>
    </m:apply>
</m:math>
 and 
<m:math display="inline">
    <m:apply>
	<m:minus/>
	<m:apply>
	    <m:divide/>
	    <m:apply>
		<m:sum/>
		<m:ci>m</m:ci>
		<m:cn>1</m:cn>
	    </m:apply>
	    <m:ci>c</m:ci>
	</m:apply>
	<m:cn>1</m:cn>
    </m:apply>
</m:math>
. This process of inferring the undefined values is known as interpolation. The rule described above is known as polar interpolation; although more sophisticated rules exist for interpolating values, linear interpolation will suffice for our explanation in this module.
</para><figure id="fig22" orient="vertical"><media id="id11642402858022" alt=""><image src="../../media/interpolation.png" mime-type="image/png"/></media>
	
      <caption><m:math display="inline">
	    <m:apply>
	      <m:ci type="fn" class="discrete">f</m:ci>
	      <m:apply>
		<m:divide/>
		<m:ci>n</m:ci>
		<m:cn>2</m:cn>
	      </m:apply>
	    </m:apply>
	  </m:math>
	  with interpolation fills in the missing values of the expansion using linear extensions. 
	</caption></figure></section>
    </section><example id="eip-31"><para id="p5">Given <m:math overflow="scroll"><m:mrow><m:mi>f</m:mi><m:mo>[</m:mo><m:mi>n</m:mi><m:mo>]</m:mo></m:mrow></m:math> we woul like to plot <m:math overflow="scroll"><m:mrow><m:mi>f</m:mi><m:mo>[</m:mo><m:mi>a</m:mi><m:mi>n</m:mi><m:mo>-</m:mo><m:mi>b</m:mi><m:mo>]</m:mo></m:mrow></m:math>.  The figure below describes a method to accomplish this.</para><figure id="fig3" orient="horizontal"><subfigure id="fig4">
	  <media id="id1164276972815" alt=""><image src="../../media/example1.png" mime-type="image/png"/></media>
	  <caption>Begin with
	    <m:math display="inline">
	      <m:apply>
		<m:ci type="fn" class="discrete">f</m:ci>
		<m:ci>n</m:ci>
	      </m:apply>
	    </m:math>
	  </caption>
	</subfigure>
	<subfigure id="fig5">
	  <media id="id1164250146370" alt=""><image src="../../media/example2.png" mime-type="image/png"/></media>
	  <caption>Then replace
	    <m:math display="inline">
	      <m:ci>n</m:ci>
	    </m:math>
	    with
	    <m:math display="inline">
	      <m:apply>
		<m:times/>
		<m:ci>a</m:ci>
		<m:ci>n</m:ci>
	      </m:apply>
	    </m:math>
	    to get
	    <m:math display="inline">
	      <m:apply>
		<m:ci type="fn" class="discrete">f</m:ci>
		<m:apply>
		  <m:times/>
		  <m:ci>a</m:ci>
		  <m:ci>n</m:ci>
		</m:apply>
	      </m:apply>
	    </m:math>
	  </caption>
	</subfigure>
	<subfigure id="fig6">
	  <media id="id1164220130859" alt=""><image src="../../media/example3.png" mime-type="image/png"/></media>
	  <caption>Finally, replace
	    <m:math display="inline">
	      <m:ci>n</m:ci>
	    </m:math>
	    with
	    <m:math display="inline">
	      <m:apply>
		<m:minus/>
		<m:ci>n</m:ci>
		<m:apply>
		  <m:divide/>
		  <m:ci>b</m:ci>
		  <m:ci>a</m:ci>
		</m:apply>
	      </m:apply>
	    </m:math>
	    to get
	    <m:math display="inline">
	      <m:apply>
		<m:eq/>
		<m:apply>
		  <m:ci type="fn" class="discrete">f</m:ci>
		  <m:apply>
		    <m:times/>
		    <m:ci>a</m:ci>
		    <m:apply>
		      <m:minus/>
		      <m:ci>n</m:ci>
		      <m:apply>
			<m:divide/>
			<m:ci>b</m:ci>
			<m:ci>a</m:ci>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:apply>
		<m:apply>
		  <m:ci type="fn" class="discrete">f</m:ci>
		  <m:apply>
		    <m:minus/>
		    <m:apply>
		      <m:times/>
		      <m:ci>a</m:ci>
		      <m:ci>n</m:ci>
		    </m:apply>
		    <m:ci>b</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	    </m:math>
	  </caption>
	</subfigure>
      </figure></example><section id="eip-570"><title>Time Reversal</title><para id="p7">
	A natural question to consider when learning about time
	scaling is: What happens when the time variable is multiplied
	by a negative number?  The answer to this is time reversal.
	This operation is the reversal of the time axis, or flipping
	the signal over the y-axis.
      </para>
      <figure id="fig7"><media id="id1164224968573" alt=""><image src="../../media/reversal.png" mime-type="image/png"/></media>
	
      <caption>Reverse the time axis</caption></figure></section></section>

    

    

    <section id="eip-731" class="cn"><title>Signal Operations Summary</title><para id="eip-291">Some common operations on signals affect the time parameter of the signal.  One of these is time shifting in which a quantity is added to the time parameter in order to advance or delay the signal.  Another is the time scaling in which the time parameter is multiplied by a quantity in order to expand or decimate the signal in time.  In the event that the quantity involved in the latter operation is negative, time reversal occurs.</para></section>
  </content>
</document>