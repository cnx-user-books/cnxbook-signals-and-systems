<document xmlns="http://cnx.rice.edu/cnxml" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:md="http://cnx.rice.edu/mdml">
  
  <title>Approximación y Proyección en el Espacio de Hilbert</title>
  
  <metadata><md:content-id>undefined</md:content-id><md:title/><md:uuid>d8599881-fe90-474b-84c7-d457252826db</md:uuid>
</metadata>
  
  <content>
    <section id="int">
      <title>Introducción</title>    
      <para id="para1">
	Dada una linea 'l' y un punto 'p' en el plano, ¿ Cuál es el punto más cercano  'm' a 'p' en 'l'?  
      </para>

      <figure id="fig1">
	<media id="idm1911552" alt=""><image src="../../media/approx_f1.png" mime-type="image/png"/></media>
	<caption>
	  Figura del punto 'p' y la linea 'l' mencionadas.
	</caption>
      </figure> 

      <para id="para2">Mismo problema: Sea <m:math><m:ci>x</m:ci></m:math>
	y <m:math><m:ci>v</m:ci></m:math> vectores en 
	<m:math>
		<m:apply>
			<m:power/>
			<m:reals/>
			<m:cn>2</m:cn>
		</m:apply>
	</m:math>. Digamos 
	<m:math>
		<m:apply>
			<m:eq/>
			<m:apply>
				<m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#norm"/>
				<m:ci>v</m:ci>
			</m:apply>
			<m:cn>1</m:cn>
		</m:apply>
	</m:math>. ¿Para qué valor de 
	<m:math><m:ci>α</m:ci></m:math> es 

	<m:math>
		<m:apply>
			<m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#norm"/>
			<m:apply>
				<m:minus/>
				<m:ci>x</m:ci>
				<m:apply>
					<m:times/>
					<m:ci>α</m:ci>
					<m:ci>v</m:ci>
				</m:apply>
			</m:apply>
		</m:apply>
		<m:msub>
			<m:mi/>
			<m:mn>2</m:mn>
		</m:msub>
	</m:math> minimizado? (¿qué punto en el espacio generado{v} <emphasis>mejor se aproxima a
	  </emphasis>
	<m:math><m:ci>x</m:ci></m:math>?) 
      </para>
      
      <figure id="fig2">
	<media id="idm3552832" alt=""><image src="../../media/approx_f2.png" mime-type="image/png"/></media>
	
      </figure> 

      <para id="para3">
	La condición es que  
	<m:math>
	  <m:apply>
	    <m:minus/>
	    <m:ci>x</m:ci>
	    <m:apply>
	      <m:times/>
	      <m:ci>
		<m:mover accent="true">
		  <m:mi>α</m:mi>
		  <m:mo>^</m:mo>
		</m:mover>
	      </m:ci>
	      <m:ci>v</m:ci>
	    </m:apply>
	  </m:apply>
	</m:math> y 
	<m:math>
	  <m:apply>
	    <m:times/>
	    <m:ci>α</m:ci>
	    <m:ci>v</m:ci>
	  </m:apply>
	</m:math> sean <term>ortogonales</term>.
      </para>
    </section>

    <section id="sec2">
      <title>Calculando α</title>
      <para id="p1_sec2">
	¿Cómo calcular 
	<m:math>
	  <m:ci>
	    <m:mover accent="true">
	      <m:mi>α</m:mi>
	      <m:mo>^</m:mo>
	    </m:mover>
	  </m:ci>
	</m:math>?
      </para>
      
      <para id="para4">Sabemos que (
	<m:math>
		<m:apply>
			<m:minus/>
			<m:ci>x</m:ci>
			<m:apply>
				<m:times/>
				<m:ci>
					<m:mover accent="true">
						<m:mi>α</m:mi>
						<m:mo>^</m:mo>
					</m:mover>
				</m:ci>
				<m:ci>v</m:ci>
			</m:apply>
		</m:apply>
	</m:math>) es perpendicular para todo vector en el espacio generado {v}, así que  

	<m:math display="block">
		<m:apply>
			<m:forall/>
			<m:bvar><m:ci>β</m:ci></m:bvar>
			<m:condition>
				<m:apply>
					<m:mo>∀</m:mo>
					<m:ci>β</m:ci>
				</m:apply>
			</m:condition>
			<m:apply>
				<m:eq/>
				<m:apply>
					<m:scalarproduct/>
					<m:apply>
						<m:minus/>
						<m:ci>x</m:ci>
						<m:apply>
							<m:times/>
							<m:ci>
								<m:mover accent="true">
									<m:mi>α</m:mi>
									<m:mo>^</m:mo>
								</m:mover>
							</m:ci>
							<m:ci>v</m:ci>
						</m:apply>
					</m:apply>
					<m:apply>
						<m:times/>
						<m:ci>β</m:ci>
						<m:ci>v</m:ci>
					</m:apply>
				</m:apply>
				<m:cn>0</m:cn>
			</m:apply>
		</m:apply>
	</m:math>
	<m:math display="block">
		<m:apply>
			<m:eq/>
			<m:apply>
				<m:minus/>
				<m:apply>
					<m:times/>
					<m:apply>
						<m:conjugate/>
						<m:ci>β</m:ci>
					</m:apply>
					<m:apply>
						<m:scalarproduct/>
						<m:ci>x</m:ci>
						<m:ci>v</m:ci>
					</m:apply>
				</m:apply>
				<m:apply>
					<m:times/>
					<m:ci>
						<m:mover accent="true">
							<m:mi>α</m:mi>
							<m:mo>^</m:mo>
						</m:mover>
					</m:ci>
					<m:apply>
						<m:conjugate/>
						<m:ci>β</m:ci>
					</m:apply>
					<m:apply>
						<m:scalarproduct/>
						<m:ci>v</m:ci>
						<m:ci>v</m:ci>
					</m:apply>
				</m:apply>
			</m:apply>
			<m:cn>0</m:cn>
		</m:apply>
	</m:math>
	
	por que 
	<m:math>
		<m:apply>
			<m:eq/>
			<m:apply>
				<m:scalarproduct/>
				<m:ci>v</m:ci>
				<m:ci>v</m:ci>
			</m:apply>
			<m:cn>1</m:cn>
		</m:apply>
	</m:math>, por lo tanto 

	<m:math display="block">
		<m:apply>
			<m:implies/>
			<m:apply>
				<m:eq/>
				<m:apply>
					<m:minus/>
					<m:apply>
						<m:scalarproduct/>
						<m:ci>x</m:ci>
						<m:ci>v</m:ci>
					</m:apply>
					<m:ci>
						<m:mover accent="true">
							<m:mi>α</m:mi>
							<m:mo>^</m:mo>
						</m:mover>
					</m:ci>
				</m:apply>
				<m:cn>0</m:cn>
			</m:apply>
			<m:apply>
				<m:eq/>
				<m:ci>
					<m:mover accent="true">
						<m:mi>α</m:mi>
						<m:mo>^</m:mo>
					</m:mover>
				</m:ci>
				<m:apply>
					<m:scalarproduct/>
					<m:ci>x</m:ci>
					<m:ci>v</m:ci>
				</m:apply>
			</m:apply>
		</m:apply>
	</m:math>

	El vector más cercano en el espacio generado{v} = 
	<m:math>
		<m:apply>
			<m:times/>
			<m:apply>
				<m:scalarproduct/>
				<m:ci>x</m:ci>
				<m:ci>v</m:ci>
			</m:apply>
			<m:ci>v</m:ci>
		</m:apply>
	</m:math>, donde 
	<m:math>
		<m:apply>
			<m:times/>
			<m:apply>
				<m:scalarproduct/>
				<m:ci>x</m:ci>
				<m:ci>v</m:ci>
			</m:apply>
			<m:ci>v</m:ci>
		</m:apply>
	</m:math> es la proyección de  <m:math><m:ci type="vector">x</m:ci></m:math> sobre <m:math><m:ci type="vector">v</m:ci></m:math>.
      </para>
      
      
      <para id="para5">
	¿Punto a un plano?
      </para>
      
      <figure id="fig3">
	<media id="idp599568" alt=""><image src="approx_f3.png" mime-type="image/png"/></media>
	
      </figure> 

      <para id="para6">
	Podemos hacer lo mismo pero en dimensiones más grandes.
      </para>

      
      <exercise id="exercise1">
	<problem id="idp672160">
	  <para id="exe1para1">
	    Sea 
	    <m:math>
	      <m:apply>
		<m:prsubset/>
		<m:ci>V</m:ci>
		<m:ci>H</m:ci>
	      </m:apply>
	    </m:math> un subespacio de un <link document="m12879" strength="3">espacio de Hilbert </link> H. Sea
	    <m:math>
	      <m:apply>
		<m:in/>
		<m:ci>x</m:ci>
		<m:ci>H</m:ci>
	      </m:apply>
	    </m:math> dado. Encontrar 
	    <m:math>
	      <m:apply>
		<m:in/>
		<m:ci>y</m:ci>
		<m:ci>V</m:ci>
	      </m:apply>
	    </m:math> que <term>mejor se aproxime</term>
	    <m:math><m:ci>x</m:ci></m:math>. es decir,  
	    <m:math>
	      <m:apply>
		<m:csymbol definitionURL="http://cnx.rice.edu/cd/cnxmath.ocd#norm"/>
		<m:apply>
		  <m:minus/>
		  <m:ci>x</m:ci>
		  <m:ci>y</m:ci>
		</m:apply>
	      </m:apply>
	    </m:math> esta minimizada. 
	  </para>
	</problem>
	<solution id="idm1642192">
	  <para id="exe1para2">
	    <list id="list1" list-type="enumerated">
	      <item>
		Encontrar una <link document="m12902" target-id="orthon_b" strength="3">base ortonormal</link>
		<m:math>
		  <m:set>
		    <m:ci><m:msub><m:mi>b</m:mi><m:mn>1</m:mn></m:msub></m:ci>
		    <m:ci>…</m:ci>
		    <m:ci><m:msub><m:mi>b</m:mi><m:mi>k</m:mi></m:msub></m:ci>
		  </m:set>
		</m:math> para 
		<m:math><m:ci>V</m:ci></m:math>
	      </item>
	      <item>
		Proyectar <m:math><m:ci>x</m:ci></m:math>
		sobre <m:math><m:ci>V</m:ci></m:math> usando 
		
		<m:math display="block">
		  <m:apply>
		    <m:eq/>
		    <m:ci>y</m:ci>
		    <m:apply>
		      <m:sum/>
		      <m:bvar><m:ci>i</m:ci></m:bvar>
		      <m:lowlimit><m:cn>1</m:cn></m:lowlimit>
		      <m:uplimit><m:ci>k</m:ci></m:uplimit>
		      <m:apply>
			<m:times/>
			<m:apply>
			  <m:scalarproduct/>
			  <m:ci>x</m:ci>
			  <m:ci><m:msub><m:mi>b</m:mi><m:mi>i</m:mi></m:msub></m:ci>
			</m:apply>
			<m:ci><m:msub><m:mi>b</m:mi><m:mi>i</m:mi></m:msub></m:ci>
		      </m:apply>
		    </m:apply>
		  </m:apply>
		</m:math>

		después <m:math><m:ci>y</m:ci></m:math> es el punto más cercano en V a x y (x-y) ⊥ V (
		<m:math>
		  <m:apply>
		    <m:forall/>
		    <m:bvar><m:ci>v</m:ci></m:bvar>
		    <m:condition>
		      <m:apply>
			<m:in/>
			<m:apply>
			  <m:mo>∀</m:mo>
			  <m:ci>v</m:ci>
			</m:apply>
			<m:ci>V</m:ci>
		      </m:apply>
		    </m:condition>
		    <m:apply>
		      <m:eq/>
		      <m:apply>
			<m:scalarproduct/>
			<m:apply>
			  <m:minus/>
			  <m:ci>x</m:ci>
			  <m:ci>y</m:ci>
			</m:apply>
			<m:ci>v</m:ci>
		      </m:apply>
		      <m:cn>0</m:cn>
		    </m:apply>
		  </m:apply>
		</m:math>
	      </item>
	    </list>
	  </para>
	</solution>
      </exercise>


      <example id="example1">
	<para id="exam1para1">
	  <m:math>
	    <m:apply>
	      <m:in/>
	      <m:ci>x</m:ci>
	      <m:apply>
		<m:power/>
		<m:reals/>
		<m:cn>3</m:cn>
	      </m:apply>
	    </m:apply>
	  </m:math>, 

	  <m:math>
	    <m:apply>
	      <m:eq/>
	      <m:ci>V</m:ci>
	      <m:apply>
		<m:ci type="fn">espacio generado</m:ci>
		<m:set>
		  <m:matrix>
		    <m:matrixrow>
		      <m:cn>1</m:cn>
		    </m:matrixrow>
		    <m:matrixrow>
		      <m:cn>0</m:cn>
		    </m:matrixrow>
		    <m:matrixrow>
		      <m:cn>0</m:cn>
		    </m:matrixrow>
		  </m:matrix>
		  <m:matrix>
		    <m:matrixrow>
		      <m:cn>0</m:cn>
		    </m:matrixrow>
		    <m:matrixrow>
		      <m:cn>1</m:cn>
		    </m:matrixrow>
		    <m:matrixrow>
		      <m:cn>0</m:cn>
		    </m:matrixrow>
		  </m:matrix>
		</m:set>
	      </m:apply>
	    </m:apply>
	  </m:math>, 

	  <m:math>
	    <m:apply>
	      <m:eq/>
	      <m:ci>x</m:ci>
	      <m:matrix>
		<m:matrixrow>
		  <m:ci>a</m:ci>
		</m:matrixrow>
		<m:matrixrow>
		  <m:ci>b</m:ci>
		</m:matrixrow>
		<m:matrixrow>
		  <m:ci>c</m:ci>
		</m:matrixrow>
	      </m:matrix>
	    </m:apply>
	  </m:math>. Por lo tanto, 

	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:ci>y</m:ci>
	      <m:apply>
		<m:sum/>
		<m:bvar><m:ci>i</m:ci></m:bvar>
		<m:lowlimit><m:cn>1</m:cn></m:lowlimit>
		<m:uplimit><m:cn>2</m:cn></m:uplimit>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:scalarproduct/>
		    <m:ci>x</m:ci>
		    <m:ci><m:msub><m:mi>b</m:mi><m:mi>i</m:mi></m:msub></m:ci>
		  </m:apply>
		  <m:ci><m:msub><m:mi>b</m:mi><m:mi>i</m:mi></m:msub></m:ci>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:plus/>
		<m:apply>
		  <m:times/>
		  <m:ci>a</m:ci>
		  <m:matrix>
		    <m:matrixrow>
		      <m:cn>1</m:cn>
		    </m:matrixrow>
		    <m:matrixrow>
		      <m:cn>0</m:cn>
		    </m:matrixrow>
		    <m:matrixrow>
		      <m:cn>0</m:cn>
		    </m:matrixrow>
		  </m:matrix>
		</m:apply>
		<m:apply>
		  <m:times/>
		  <m:ci>b</m:ci>
		  <m:matrix>
		    <m:matrixrow>
		      <m:cn>0</m:cn>
		    </m:matrixrow>
		    <m:matrixrow>
		      <m:cn>1</m:cn>
		    </m:matrixrow>
		    <m:matrixrow>
		      <m:cn>0</m:cn>
		    </m:matrixrow>
		  </m:matrix>
		</m:apply>
	      </m:apply>
	      <m:matrix>
		<m:matrixrow>
		  <m:ci>a</m:ci>
		</m:matrixrow>
		<m:matrixrow>
		  <m:ci>b</m:ci>
		</m:matrixrow>
		<m:matrixrow>
		  <m:cn>0</m:cn>
		</m:matrixrow>
	      </m:matrix>
	    </m:apply>
	  </m:math>
	</para>

	<!--
      <figure id='fig4'>
      <name></name>
      <media type="image/png" src="fig4.png"/>
      <caption></caption>
      </figure> 
	-->

      </example>


      <example id="example2">
	<para id="exam2para1">
	  V = {espacio de las señales periódicas con frecuancia no mayor que	  <m:math>
	    <m:apply>
	      <m:times/>
	      <m:cn>3</m:cn>
	      <m:ci>
		<m:msub><m:mi>w</m:mi><m:mn>0</m:mn></m:msub>
	      </m:ci>
	    </m:apply>
	  </m:math>}. Dada f(t) periódica, ¿Cúal es la señal en  V que mejor se aproxima a  f?

	  <list id="list2" list-type="enumerated">
	<item>
	      { 
	      <m:math>
			<m:apply>
				<m:times/>
				<m:apply>
					<m:divide/>
					<m:cn>1</m:cn>
					<m:apply>
						<m:root/>
						<m:ci>T</m:ci>
					</m:apply>
				</m:apply>
				<m:apply>
					<m:exp/>
					<m:apply>
						<m:times/>
						<m:imaginaryi/>
						<m:ci>
							<m:msub><m:mi>w</m:mi><m:mn>0</m:mn></m:msub>
						</m:ci>
						<m:ci>k</m:ci>
						<m:ci>t</m:ci>
					</m:apply>
				</m:apply>
			</m:apply>
		</m:math>, k = -3, -2, ..., 2, 3} es una  ONB para V
	    </item>
	<item>
		<m:math>
			<m:apply>
				<m:eq/>
				<m:apply>
					<m:ci type="fn">g</m:ci>
					<m:ci>t</m:ci>
				</m:apply>
				<m:apply>
					<m:times/>
					<m:apply>
						<m:divide/>
						<m:cn>1</m:cn>
						<m:ci>T</m:ci>
					</m:apply>
					<m:apply>
						<m:sum/>
						<m:bvar><m:ci>k</m:ci></m:bvar>
						<m:lowlimit>
							<m:cn>-3</m:cn>
						</m:lowlimit>
						<m:uplimit>
							<m:cn>3</m:cn>
						</m:uplimit>
						<m:apply>
							<m:times/>
							<m:apply>
								<m:scalarproduct/>
								<m:apply>
									<m:ci type="fn">f</m:ci>
									<m:ci>t</m:ci>
								</m:apply>
								<m:apply>
									<m:exp/>
									<m:apply>
										<m:times/>
										<m:imaginaryi/>
										<m:ci>
											<m:msub><m:mi>w</m:mi><m:mn>0</m:mn></m:msub>
										</m:ci>
										<m:ci>k</m:ci>
										<m:ci>t</m:ci>
									</m:apply>
								</m:apply>
							</m:apply>
							<m:apply>
								<m:exp/>
								<m:apply>
									<m:times/>
									<m:imaginaryi/>
									<m:ci>
										<m:msub><m:mi>w</m:mi><m:mn>0</m:mn></m:msub>
									</m:ci>
									<m:ci>k</m:ci>
									<m:ci>t</m:ci>
								</m:apply>
							</m:apply>
						</m:apply>
					</m:apply>
				</m:apply>
			</m:apply>
		</m:math> es la señal más cercana en V para f(t)
	      ⇒ reconstruya f(t) usando solamente 7 términos  de su  <link document="m12893" strength="3">serie de Fourier
	      </link>.
	    </item>
</list>
	</para>
      </example>

      
      <example id="example3">
	<para id="exam3para1">Sea V = { funciones constantes por trozos entre los números enteros}
	</para>

	<!--      
      <figure id='fig5'>
      <name></name>
      <media type="image/png" src="fig5.png"/>
      <caption></caption>
      </figure> 
	-->

	<para id="exam3para2">
	  <list id="list3" list-type="enumerated">
	    <item>
	      ONB para V.
	    </item>
	  </list>
	</para>
	
	<!--      
      <figure id='fig6'>
      <name></name>
      <media type="image/png" src="fig6.png"/>
      <caption></caption>
      </figure> 
	-->
	
	<para id="exam3para3">
	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:ci>
		<m:msub><m:mi>b</m:mi><m:mi>i</m:mi></m:msub>
	      </m:ci>
	      <m:piecewise>
		<m:piece>
		  <m:cn>1</m:cn>
		  <m:apply>
		    <m:lt/>
		    <m:apply>
		      <m:leq/>
		      <m:apply>
			<m:minus/>
			<m:ci>i</m:ci>
			<m:cn>1</m:cn>
		      </m:apply>
		      <m:ci>t</m:ci>
		    </m:apply>
		    <m:ci>i</m:ci>
		  </m:apply>
		</m:piece>
		<m:otherwise>
		  <m:cn>0</m:cn>
		</m:otherwise>
	      </m:piecewise>
	    </m:apply>
	  </m:math>

	  donde
	  {<m:math><m:ci><m:msub><m:mi>b</m:mi><m:mi>i</m:mi></m:msub></m:ci></m:math>}
	  es una ONB.
	</para>

	<!--   
      <figure id='fig7'>
      <name></name>
      <media type="image/png" src="fig7.png"/>
      <caption></caption>
      </figure> 
	-->
	
	<para id="exam3para4">
	  ¿La mejor aproximación constante por trozos?

	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:apply>
		<m:ci type="fn">g</m:ci>
		<m:ci>t</m:ci>
	      </m:apply>
	      <m:apply>
		<m:sum/>
		<m:bvar><m:ci>i</m:ci></m:bvar>
		<m:lowlimit>
		  <m:apply>
		    <m:minus/>
		    <m:infinity/>
		  </m:apply>
		</m:lowlimit>
		<m:uplimit><m:infinity/></m:uplimit>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:scalarproduct/>
		    <m:ci>f</m:ci>
		    <m:ci>
		      <m:msub><m:mi>b</m:mi><m:mi>i</m:mi></m:msub>
		    </m:ci>
		  </m:apply>
		  <m:ci>
		    <m:msub><m:mi>b</m:mi><m:mi>i</m:mi></m:msub>
		  </m:ci>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:math>

	  <m:math display="block">
	    <m:apply>
	      <m:eq/>
	      <m:apply>
		<m:scalarproduct/>
		<m:ci>f</m:ci>
		<m:ci>
		  <m:msub><m:mi>b</m:mi><m:mi>i</m:mi></m:msub>
		</m:ci>
	      </m:apply>
	      <m:apply>
		<m:int/>
		<m:bvar><m:ci>t</m:ci></m:bvar>
		<m:lowlimit>
		  <m:apply>
		    <m:minus/>
		    <m:infinity/>
		  </m:apply>
		</m:lowlimit>
		<m:uplimit><m:infinity/></m:uplimit>
		<m:apply>
		  <m:times/>
		  <m:apply>
		    <m:ci type="fn">f</m:ci>
		    <m:ci>t</m:ci>
		  </m:apply>
		  <m:apply>
		    <m:ci type="fn">
		      <m:msub><m:mi>b</m:mi><m:mi>i</m:mi></m:msub>
		    </m:ci>  
		    <m:ci>t</m:ci>
		  </m:apply>
		</m:apply>
	      </m:apply>
	      <m:apply>
		<m:int/>
		<m:bvar><m:ci>t</m:ci></m:bvar>
		<m:lowlimit>
		  <m:apply>
		    <m:minus/>
		    <m:ci>i</m:ci>
		    <m:cn>1</m:cn>
		  </m:apply>
		</m:lowlimit>
		<m:uplimit>
		  <m:ci>i</m:ci>
		</m:uplimit>
		<m:apply>
		  <m:ci type="fn">f</m:ci>
		  <m:ci>t</m:ci>
		</m:apply>
	      </m:apply>
	    </m:apply>
	  </m:math>
	</para>
      </example>

      <example id="approximation_demo">
	<para id="approximation_demo_1">
	  Esta demostración explora la aproximación usando una base de  Fourier
	  y una base de las ondoletas de Haar. Véase <link document="m11550">aqui</link> para las instrucciones de como usar el demo.
	</para>
	<media id="idp4257968" alt="" display="block"><labview src="Approximation.llb" viname="approximation.viinfo" version="7.0" mime-type="application/x-labview-llb"><param name="viinfo" value="approximation.viinfo"/></labview></media>
      </example>

    </section>

  </content>
</document>